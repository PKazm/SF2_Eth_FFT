/*
 * main.cpp
 *
 *  Created on: Apr 9, 2020
 *      Author: Phoenix136
 */


#include <stdio.h>

#include "../firmware/drivers/mss_uart/mss_uart.h"
#include "../firmware/drivers/mss_gpio/mss_gpio.h"

#include "../firmware/drivers/mss_ethernet_mac/mss_ethernet_mac_types.h"
#include "../firmware/drivers/mss_ethernet_mac/mss_ethernet_mac.h"
#include "../firmware/drivers/mss_ethernet_mac/phy.h"

#include "FFT_apb.h"


#include "../firmware/CMSIS/system_m2sxxx.h"


#include "../firmware/FFT_Accel_system_hw_platform.h"

/*-------------------------------------------------------------------------*//**
 * main definitions
 */
void init_periph(void);

void do_eth_cmd_code(void);

void report_eth_stat_over_uart(void);


void uart0_rx_int_handler(mss_uart_instance_t *);

void eth_tx_callback(void * caller_info);
void eth_rx_callback(uint8_t * p_rx_packet, uint32_t pckt_length, void * p_user_data);
char eth_check_address(uint8_t *);
uint32_t eth_get_code(uint8_t * packet_data);
void report_eth_status(void);
void report_mac_phy_reg(void);
void load_fft_samples(void);
void read_fft_samples(void);
void report_fft_status(void);

void eth_gen_checksum(uint8_t * buffer, uint32_t length);
void eth_arp_announce(void);
void eth_send_big_data(void);

uint32_t test_GPIO_high(uint32_t GPIO_MASK);

/*-------------------------------------------------------------------------*//**
 * main defines
 */

#define RX_BUFF_SIZE    64

#define ETH_PACKET_SIZE                  1514u
#define ETH_PACKET_DATA_START			42

#define ETH_P_NOP		0u
#define ETH_P_C0DE		1u
#define ETH_P_DA7A		2u
#define ETH_P_ARP_PROBE 3u

#define ETH_TX_DAT_LEN		513
#define ETH_TX_IPV4_LEN_MSB	(uint8_t)((28u + ETH_TX_DAT_LEN) >> 8) & 0xff
#define ETH_TX_IPV4_LEN_LSB (uint8_t)((28u + ETH_TX_DAT_LEN)) & 0xff

#define ETHTX_UDP_LEN_MSB (uint8_t)((8u + ETH_TX_DAT_LEN) >> 8) & 0xff
#define ETHTX_UDP_LEN_LSB (uint8_t)((8u + ETH_TX_DAT_LEN)) & 0xff

/*-------------------------------------------------------------------------*//**
 * main globals
 */

char port_check = 0;
int eth_cmd_code = 0;
char do_big_data = 0;
int8_t input_smpls[1024];
int8_t input_smpls2[1024];

fft_instance_t fft_fab;

/*------------------------------------------------------------------------------
 * MSS MAC, Ethernet
 */
mss_mac_cfg_t mac_config;
const static uint8_t mac_address[6] = {0x22, 0x22, 0x22, 0x22, 0x22, 0x22};
//const static uint8_t mac_address[6] = {0x00, 0xA0, 0x87, 0x22, 0x22, 0x22};
const static uint8_t tx_ip[4] = {100, 100, 100, 100};
const static uint8_t my_ip[4] = {100, 100, 100, 200};
volatile uint32_t g_pckt_rcvd_len = 0;

uint16_t eth_tx_id = 0x0000u;
static uint8_t g_mac_tx_buffer[ETH_PACKET_SIZE] = \
      {0x00,0xe0,0x4c,0x68,0x01,0x2f, mac_address[0],mac_address[1],mac_address[2],mac_address[3],mac_address[4],mac_address[5], 0x08,0x00,
	  0x45, 0x00, ETH_TX_IPV4_LEN_MSB,ETH_TX_IPV4_LEN_LSB, 0xFF,0xFF, 0x00,0x00, 0x80, 0x11, 0x00,0x00, my_ip[0],my_ip[1],my_ip[2],my_ip[3], tx_ip[0],tx_ip[1],tx_ip[2],tx_ip[3],
	  0xDA,0x7A, 0xDA,0x7A, ETHTX_UDP_LEN_MSB,ETHTX_UDP_LEN_LSB, 0x00,0x00};
static uint8_t g_mac_rx_buffer_0[ETH_PACKET_SIZE];
static uint8_t g_mac_rx_buffer_1[ETH_PACKET_SIZE];

static volatile uint32_t g_mac_tx_buffer_used = 1u;

static uint8_t arp_anounce_buffer[42] = \
		{0xff,0xff,0xff,0xff,0xff,0xff, mac_address[0],mac_address[1],mac_address[2],mac_address[3],mac_address[4],mac_address[5], 0x08,0x06,
		0x00,0x01, 0x08,0x00, 0x06, 0x04, 0x00,0x01,
		mac_address[0],mac_address[1],mac_address[2],mac_address[3],mac_address[4],mac_address[5], my_ip[0],my_ip[1],my_ip[2],my_ip[3],
		0x00,0x00,0x00,0x00,0x00,0x00, my_ip[0],my_ip[1],my_ip[2],my_ip[3]};
static uint8_t test_buffer[] = \
		{0x00,0xe0,0x4c,0x68,0x01,0x2f, mac_address[0],mac_address[1],mac_address[2],mac_address[3],mac_address[4],mac_address[5], 0x08,0x00,
		0x45, 0x00, 0x00,0x20, 0x00,0x00, 0x00,0x00, 0x80, 0x11, 0x28,0xd8, my_ip[0],my_ip[1],my_ip[2],my_ip[3], tx_ip[0],tx_ip[1],tx_ip[2],tx_ip[3],
		0xDA,0x7A, 0xDA,0x7A, 0x00,0x0c, 0x00,0x00, 0xde,0xdd,0xbe,0xef};

static volatile uint32_t g_mac_tx_arp_used = 2u;



/*------------------------------------------------------------------------------
 * MAIN
 */
int main(){
	init_periph();

	for(;;){
		if(do_big_data != 0){
			eth_send_big_data();
			//do_big_data = 0;
		}
		switch (port_check)
		{
		case ETH_P_C0DE:
			do_eth_cmd_code();
			port_check = 0;
			break;
		case ETH_P_DA7A:
			load_fft_samples();
			port_check = 0;
			break;
		case ETH_P_ARP_PROBE:
			eth_arp_announce();
			port_check = 0;
			break;
		default:
			break;
		}
	}
}


void init_periph(void){
	/*-------------------------------------------------------------------------*//**
	* MSS_UART
	*/
	MSS_UART_init(
			&g_mss_uart0,
			MSS_UART_921600_BAUD,//MSS_UART_115200_BAUD
			MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY | MSS_UART_ONE_STOP_BIT
		);
	MSS_UART_enable_irq(
			&g_mss_uart0,
			MSS_UART_RBF_IRQ
		);
	MSS_UART_set_rx_handler(
			&g_mss_uart0,
			uart0_rx_int_handler,
			MSS_UART_FIFO_SINGLE_BYTE
		);
	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"uart initialized!\n\r");

	/*-------------------------------------------------------------------------*//**
	* MSS_GPIO
	*/

	MSS_GPIO_init();

	MSS_GPIO_config(MSS_GPIO_8, MSS_GPIO_INPUT_MODE | MSS_GPIO_IRQ_EDGE_POSITIVE);
	MSS_GPIO_config(MSS_GPIO_9, MSS_GPIO_INPUT_MODE | MSS_GPIO_IRQ_EDGE_POSITIVE);
	MSS_GPIO_enable_irq(MSS_GPIO_8);
	MSS_GPIO_enable_irq(MSS_GPIO_9);

	/*-------------------------------------------------------------------------*//**
	* Fabric FFT
	*/

	fft_init(&fft_fab, FFT_APB_WRAPPER_0);

	NVIC_EnableIRQ(FabricIrq1_IRQn);

	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"fft initialized!\n\r");

	/*-------------------------------------------------------------------------*//**
	* MSS_MAC, VSC8541 PHY, Ethernet stuff
	*/
	NVIC_DisableIRQ(FabricIrq0_IRQn);

	MSS_MAC_cfg_struct_def_init(&mac_config);
	mac_config.mac_addr[0] = mac_address[0];
	mac_config.mac_addr[1] = mac_address[1];
	mac_config.mac_addr[2] = mac_address[2];
	mac_config.mac_addr[3] = mac_address[3];
	mac_config.mac_addr[4] = mac_address[4];
	mac_config.mac_addr[5] = mac_address[5];
	mac_config.speed_duplex_select = MSS_MAC_ANEG_100M_FD;
	//mac_config.speed_duplex_select = MSS_MAC_ANEG_ALL_SPEEDS;
	mac_config.phy_addr = 0x00;
	mac_config.pad_n_CRC = MSS_MAC_PAD_N_CRC_DISABLE;


	MSS_MAC_init(&mac_config);
	MSS_MAC_receive_pkt(g_mac_rx_buffer_0, (void *)g_mac_rx_buffer_0);
	MSS_MAC_receive_pkt(g_mac_rx_buffer_1, (void *)g_mac_rx_buffer_1);
	MSS_MAC_set_tx_callback(eth_tx_callback);
	MSS_MAC_set_rx_callback(eth_rx_callback);


	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"mac initialized!\n\r");

	eth_arp_announce();

	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"ARP Sent!\n\r");


	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"== everything is set up! ==\n\r");

}

void do_eth_cmd_code(void){
	switch (eth_cmd_code) {
		case 1:
			read_fft_samples();
			break;
		case 2:
			fft_read_done(&fft_fab);
			break;
		case 3:
			report_fft_status();
			break;
		case 4:
			report_eth_status();
			break;
		case 5:
			report_mac_phy_reg();
			break;
		default:
			break;
	}
	eth_cmd_code = 0;
}


void report_eth_stat_over_uart(void){
	uint8_t link_status;
    mss_mac_speed_t speed;
    uint8_t fullduplex;

	link_status = MSS_MAC_phy_get_link_status(&speed, &fullduplex);
	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"Link is: ");
	if(link_status == MSS_MAC_LINK_UP){
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"UP!\r\n");
		switch(speed)
		{
			case MSS_MAC_10MBPS:
				MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"    10Mbps ");
				break;
			case MSS_MAC_100MBPS:
				MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"    100Mbps ");
				break;
			case MSS_MAC_1000MBPS:
				MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"    1000Mbps ");
				break;
			default:
				MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"    nope ");
				break;
		}
		if(1u == fullduplex)
		{
			MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"Full Duplex\r\n");
		}
		else
		{
			MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"Half Duplex\r\n");
		}
	}
	else{
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"DOWN!\r\n");
	}


}

void uart0_rx_int_handler(mss_uart_instance_t * this_uart){
	uint8_t rx_buff[RX_BUFF_SIZE];
	uint32_t rx_idx  = 0;
	size_t rx_size;
	rx_size = MSS_UART_get_rx(this_uart, rx_buff, sizeof(rx_buff));
	//uart_rx_to_nokia_raw(rx_buff, rx_size);
	//uart_rx_to_nokia_char(rx_buff, rx_size);
	//uart_rx_to_spi_mem(rx_buff, rx_size);
}

void eth_tx_callback(void * caller_info){
	*((uint32_t *)caller_info) = 0;
	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"Ethernet Transmit Sent\n\r");
}

void eth_rx_callback(
	uint8_t * p_rx_packet,
	uint32_t pckt_length,
	void * p_user_data
)
{
	port_check = eth_check_address(p_rx_packet);
	char buffer[128];
	static uint8_t * dest_array = input_smpls2;

	if(ETH_P_DA7A == port_check){

		snprintf(buffer, sizeof(buffer), "\n\rRX pkt size = %d\r\n", (int)pckt_length);
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"========================\n\r");
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"Ethernet packet received\n\r");
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)buffer);


		//MSS_MAC_send_pkt(g_mac_tx_buffer, 64u, (void *)&g_mac_tx_buffer_used);
		/*
		for(int i = 0; i < pckt_length; i++){
			snprintf(buffer, sizeof(buffer), "%i", p_rx_packet[i]);
			MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)buffer);
		}
		*/

		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"\n\rDATA DONE\n\r");
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"========================\n\r");

		if(dest_array == (uint8_t *)&input_smpls){
			dest_array = input_smpls2;
		}
		else{
			dest_array = input_smpls;
		}

		for(int i = 0; i < 1024; i++){
			dest_array[i] = p_rx_packet[i + 42];
			//snprintf(buffer, sizeof(buffer), "datum %d = %d\r\n", (int)i, (int)p_rx_packet[i + 42]);
			//MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)buffer);
		}
	}
	else if(ETH_P_C0DE == port_check){
		eth_cmd_code = eth_get_code(p_rx_packet);
	}
	
	//eth_arp_announce();


	MSS_MAC_receive_pkt((uint8_t *)p_user_data, p_user_data);
	

}

char eth_check_address(uint8_t * packet_data){
	/* Check Destination address */
	if(packet_data[30] == 100 && packet_data[31] == 100 && packet_data[32] == 100 && (packet_data[33] == 2 || packet_data[33] == 255)){
		/* Check Destination port */
		if(packet_data[36] == 0xC0 && packet_data[37] == 0xDE){
			/* 0xC0DE
			 * data on the 0xC0DE port contains control codes, e.g. start/stop or set flags on peripherals
			 * probably a 4 byte unsigned integer that triggers a function on this here ARM core
			 */
			MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"C0DE received, Applying Code\n\r");
			return ETH_P_C0DE;
		}
		else if(packet_data[36] == 0xDA && packet_data[37] == 0x7A){
			/* 0xDA7A
			 * data on the 0xDA7A port contains actual data.
			 * Where this data goes depends on flags set with 0xC0DE
			 */
			MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"DA7A received, Receiving Data\n\r");
			return ETH_P_DA7A;
		}
		//else if(packet_data[36] == 0xb0 && packet_data[37] == 0x0b){
		//	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"B00B received, done reading data\n\r");
		//	return 3u;
		//}
		//else if(packet_data[36] == 0xd0 && packet_data[37] == 0x0f){
		//	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"D00F received, sending FFT status\n\r");
		//	return 4u;
		//}
	}
	else if(packet_data[0] == 0xff && packet_data[1] == 0xff && packet_data[2] == 0xff && packet_data[3] == 0xff && packet_data[4] == 0xff && packet_data[5] == 0xff){
		/* MAC address broadast */
		/* Check if ARP probe */
		if(packet_data[12] == 0x08 && packet_data[13] == 0x06){
			return ETH_P_ARP_PROBE;
		}
	}
	return ETH_P_NOP;
}

uint32_t eth_get_code(uint8_t * packet_data){
	uint32_t the_code = 0;
	
	for(int i = 0; i < 4; i++){
		the_code = (the_code << 8) | (packet_data[i + 42] & 0xff);
	}

	return the_code;
}

void report_eth_status(void){
	uint8_t link_status;
    mss_mac_speed_t speed;
    uint8_t fullduplex;

	link_status = MSS_MAC_phy_get_link_status(&speed, &fullduplex);
	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"Link is: ");
	if(link_status == MSS_MAC_LINK_UP){
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"UP!\r\n");
		switch(speed)
		{
			case MSS_MAC_10MBPS:
				MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"    10Mbps ");
			break;

			case MSS_MAC_100MBPS:
				MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"    100Mbps ");
			break;
			case MSS_MAC_1000MBPS:
				MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"    1000Mbps ");
			break;
			default:
				MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"    nope ");
			break;
		}
		if(1u == fullduplex)
		{
			MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"Full Duplex\r\n");
		}
		else
		{
			MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"Half Duplex\r\n");
		}
	}
	else{
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"DOWN!\r\n");
	}
}

void report_mac_phy_reg(void){
	char buffer[128];
	uint16_t phy_reg;

	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"============\r\nPHY REGISTERS\r\n");

	for(uint8_t i = 0; i < 32; i++){
		phy_reg = MSS_MAC_read_phy_reg(mac_config.phy_addr, i);
		snprintf(buffer, sizeof(buffer), "phy reg %d : %x\r\n", (int)i, (int)phy_reg);
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)buffer);
	}

	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"============\r\n");
}

void load_fft_samples(void){
	//MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"load started\n\r");

	char buffer[128];
	int16_t sample;

	for(int i = 0; i < 1024; i+=2){
		sample = input_smpls[i];
		sample = (sample << 8) | (input_smpls[i+1] & 0xff);
		fft_load_smpl(&fft_fab, sample, 0u);
		//snprintf(buffer, sizeof(buffer), "datum %d = %d\r\n", (int)i, (int)sample);
		//MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)buffer);
	}
	for(int i = 0; i < 1024; i+=2){
		sample = input_smpls2[i];
		sample = (sample << 8) | input_smpls2[i+1];
		fft_load_smpl(&fft_fab, sample, 0u);
		//snprintf(buffer, sizeof(buffer), "datum %d = %d\r\n", (int)i, (int)sample);
		//MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)buffer);
	}

	fft_load_done(&fft_fab);

	
	//MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"load finished\r\n");
}


void read_fft_samples(void){
	char buffer[128];
	int16_t fft_result_real[513];
	int16_t fft_result_imag[513];
	uint16_t fft_result_abs;
	int byte_cnt = ETH_PACKET_DATA_START;

	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"return started\r\n");

	/* ipv4 packet id */
	g_mac_tx_buffer[18] = (uint8_t)((eth_tx_id >> 8) & 0xff);
	g_mac_tx_buffer[19] = (uint8_t)(eth_tx_id & 0xff);
	//eth_tx_id++;


	for(int i = 0; i < 513; i++){
		byte_cnt++;
		//fft_read_smpl(&fft_fab, (uint16_t)i, fft_result_real[i], fft_result_imag[i], fft_result_abs);
		fft_set_output_smpl(&fft_fab, (uint16_t)i);
		//fft_result_real[i] = fft_get_real_out(&fft_fab);
		//fft_result_imag[i] = fft_get_imag_out(&fft_fab);
		fft_result_abs = fft_get_abs_val_out(&fft_fab);
		g_mac_tx_buffer[i + ETH_PACKET_DATA_START] = (uint8_t)fft_result_abs;

		//snprintf(buffer, sizeof(buffer), "return %d = %d + i%d\r\n", (int)i, (int)fft_result_real[i], (int)fft_result_imag[i]);
		//MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)buffer);
	}

	MSS_MAC_send_pkt(g_mac_tx_buffer, byte_cnt, (void *)&g_mac_tx_buffer_used);
	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"return finished\r\n");
}

void report_fft_status(void){
	//char buffer[128];
	uint8_t fft_status;
	uint8_t status_test;

	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"==========\r\nstatus started\r\n");
	fft_status = fft_get_status(&fft_fab);
	status_test = fft_status & STAT_W_READY;
	if(status_test != 0){
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"INPUT READY\r\n");
	}
	status_test = fft_status & STAT_W_FULL;
	if(status_test != 0){
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"INPUT FULL\r\n");
	}
	status_test = fft_status & STAT_R_READY;
	if(status_test != 0){
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"OUTPUT READY\r\n");
	}
	status_test = fft_status & STAT_R_VALID;
	if(status_test != 0){
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"OUTPUT VALID\r\n");
	}
	status_test = fft_status & STAT_ABS_VALID;
	if(status_test != 0){
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"ABS VALUE VALID\r\n");
	}
	status_test = fft_status & STAT_INT_ACTIVE;
	if(status_test != 0){
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"INTERRUPT ACTIVE\r\n");
	}

	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"==========\r\ncontrol register\r\n");

	fft_status = fft_get_ctrl(&fft_fab);
	status_test = fft_status & CTRL_WRITE_EN;
	if(status_test != 0){
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"WRITE ENABLED\r\n");
	}
	status_test = fft_status & CTRL_LOAD_DONE;
	if(status_test != 0){
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"WRITE DONE\r\n");
	}
	status_test = fft_status & CTRL_READ_DONE;
	if(status_test != 0){
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"READ DONE\r\n");
	}

	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"status finished\r\n==========\r\n");
}

void eth_gen_checksum(uint8_t * buffer, uint32_t length){

}

void eth_arp_announce(void){

	MSS_MAC_send_pkt(arp_anounce_buffer, sizeof(arp_anounce_buffer), (void *)&g_mac_tx_buffer_used);
	MSS_MAC_send_pkt(test_buffer, sizeof(test_buffer), (void *)&g_mac_tx_buffer_used);
}

void eth_send_big_data(void){
	MSS_MAC_send_pkt(g_mac_tx_buffer, sizeof(g_mac_tx_buffer), (void *)&g_mac_tx_buffer_used);
}

uint32_t test_GPIO_high(uint32_t GPIO_MASK){
	uint32_t gpio_inputs;
	gpio_inputs = MSS_GPIO_get_inputs();
	gpio_inputs &= GPIO_MASK;

	return gpio_inputs;
}

/*-------------------------------------------------------------------------*//**
 * GPIO8_IRQHandler() reads Board_Button[0]; SW1
 * big data out
 */
void GPIO8_IRQHandler(void){

	if(0 != test_GPIO_high(MSS_GPIO_8_MASK)){
		do_big_data ^= 1;
	}

	/*
	if(do_big_data != 0){
		// build output buffer?
	}
	*/

	MSS_GPIO_clear_irq(MSS_GPIO_8);
}

/*-------------------------------------------------------------------------*//**
 * GPIO9_IRQHandler()  reads Board_Button[1]; SW2
 * dump PHY and MAC registers
 */
void GPIO9_IRQHandler(void){

	if(0 != test_GPIO_high(MSS_GPIO_9_MASK)){
		eth_arp_announce();
		report_eth_status();
		report_mac_phy_reg();
	}

	MSS_GPIO_clear_irq(MSS_GPIO_9);
}

/*-------------------------------------------------------------------------*//**
 * FabricIrq0_IRQHandler() triggers on MDINT from the Ethernet PHY
 * TODO
 */
void FabricIrq0_IRQHandler(void){

}

/*-------------------------------------------------------------------------*//**
 * FabricIrq1_IRQHandler() triggers on the FFT completion
 * exports data as an ethernet frame and clears the interrupt
 */
void FabricIrq1_IRQHandler(void){
	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"FFT Interrupt Triggered\r\n");
	read_fft_samples();
	NVIC_ClearPendingIRQ(FabricIrq1_IRQn);
	fft_int_clr(&fft_fab);
}
