/*
 * main.cpp
 *
 *  Created on: Apr 9, 2020
 *      Author: Phoenix136
 */


#include <stdio.h>

#include "../firmware/drivers/mss_uart/mss_uart.h"

#include "../firmware/drivers/mss_ethernet_mac/mss_ethernet_mac_types.h"
#include "../firmware/drivers/mss_ethernet_mac/mss_ethernet_mac.h"
#include "../firmware/drivers/mss_ethernet_mac/phy.h"

#include "FFT_apb.h"


#include "../firmware/CMSIS/system_m2sxxx.h"


#include "../firmware/FFT_Accel_system_hw_platform.h"

/*-------------------------------------------------------------------------*//**
 * main definitions
 */
void init_periph(void);

void report_eth_stat_over_uart(void);


void uart0_rx_int_handler(mss_uart_instance_t *);

void eth_tx_callback(void * caller_info);
void eth_rx_callback(uint8_t * p_rx_packet, uint32_t pckt_length, void * p_user_data);
char eth_check_address(uint8_t *);

/*-------------------------------------------------------------------------*//**
 * main defines
 */

#define RX_BUFF_SIZE    64

#define ETH_PACKET_SIZE                  1514u

/*-------------------------------------------------------------------------*//**
 * main globals
 */


fft_instance_t fft_fab;

/*------------------------------------------------------------------------------
 * MSS MAC, Ethernet
 */
mss_mac_cfg_t mac_config;
const static uint8_t mac_address[6] = {0x22, 0x22, 0x22, 0x22, 0x22, 0x22};
volatile uint32_t g_pckt_rcvd_len = 0;

static uint8_t g_mac_tx_buffer[ETH_PACKET_SIZE] = \
      {0x00,0xe0,0x4c,0x68,0x01,0x2f, 0xff,0xff,0xff,0xff,0xff,0xff};
static uint8_t g_mac_rx_buffer[ETH_PACKET_SIZE];

static volatile uint32_t g_mac_tx_buffer_used = 1u;



/*------------------------------------------------------------------------------
 * MAIN
 */
int main(){
	init_periph();

	for(;;){

	}
}


void init_periph(void){
	/*-------------------------------------------------------------------------*//**
	* MSS_UART
	*/
	MSS_UART_init(
			&g_mss_uart0,
			MSS_UART_921600_BAUD,//MSS_UART_115200_BAUD
			MSS_UART_DATA_8_BITS | MSS_UART_NO_PARITY | MSS_UART_ONE_STOP_BIT
		);
	MSS_UART_enable_irq(
			&g_mss_uart0,
			MSS_UART_RBF_IRQ
		);
	MSS_UART_set_rx_handler(
			&g_mss_uart0,
			uart0_rx_int_handler,
			MSS_UART_FIFO_SINGLE_BYTE
		);
	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"uart initialized!\n\r");


	/*-------------------------------------------------------------------------*//**
	* Fabric FFT
	*/

	fft_init(&fft_fab, FFT_APB_WRAPPER_0);

	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"fft initialized!\n\r");

	/*-------------------------------------------------------------------------*//**
	* MSS_MAC, VSC8541 PHY, Ethernet stuff
	*/
	MSS_MAC_cfg_struct_def_init(&mac_config);
	mac_config.mac_addr[0] = mac_address[0];
	mac_config.mac_addr[1] = mac_address[1];
	mac_config.mac_addr[2] = mac_address[2];
	mac_config.mac_addr[3] = mac_address[3];
	mac_config.mac_addr[4] = mac_address[4];
	mac_config.mac_addr[5] = mac_address[5];
	mac_config.speed_duplex_select = MSS_MAC_ANEG_100M_FD;
	mac_config.phy_addr = 0x00;


	MSS_MAC_init(&mac_config);
	MSS_MAC_receive_pkt(g_mac_rx_buffer, 0);
	MSS_MAC_set_tx_callback(eth_tx_callback);
	MSS_MAC_set_rx_callback(eth_rx_callback);

	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"mac initialized!\n\r");


	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"== everything is set up! ==\n\r");

}


void report_eth_stat_over_uart(void){
	uint8_t link_status;
    mss_mac_speed_t speed;
    uint8_t fullduplex;

	link_status = MSS_MAC_phy_get_link_status(&speed, &fullduplex);
	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"Link is: ");
	if(link_status == MSS_MAC_LINK_UP){
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"UP!\r\n");
		switch(speed)
		{
			case MSS_MAC_10MBPS:
				MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"    10Mbps ");
			break;

			case MSS_MAC_100MBPS:
				MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"    100Mbps ");
			break;
			case MSS_MAC_1000MBPS:
				MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"    1000Mbps ");
			break;
			default:
				MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"    nope ");
			break;
		}
		if(1u == fullduplex)
		{
			MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"Full Duplex\r\n");
		}
		else
		{
			MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t*)"Half Duplex\r\n");
		}
	}
	else{
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"DOWN!\r\n");
	}


}

void uart0_rx_int_handler(mss_uart_instance_t * this_uart){
	uint8_t rx_buff[RX_BUFF_SIZE];
	uint32_t rx_idx  = 0;
	size_t rx_size;
	rx_size = MSS_UART_get_rx(this_uart, rx_buff, sizeof(rx_buff));
	//uart_rx_to_nokia_raw(rx_buff, rx_size);
	//uart_rx_to_nokia_char(rx_buff, rx_size);
	//uart_rx_to_spi_mem(rx_buff, rx_size);
}

void eth_tx_callback(void * caller_info){
	*((uint32_t *)caller_info) = 0;
	MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"Ethernet Response Sent\n\r");
}

void eth_rx_callback(
	uint8_t * p_rx_packet,
	uint32_t pckt_length,
	void * p_user_data
)
{
	char port_check = eth_check_address(p_rx_packet);

	if(1u == port_check){

		char buffer[128];
		snprintf(buffer, sizeof(buffer), "\n\rRX pkt size = %d\r\n", (int)pckt_length);
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"========================\n\r");
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"Ethernet packet received\n\r");
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)buffer);


		//MSS_MAC_send_pkt(g_mac_tx_buffer, 64u, (void *)&g_mac_tx_buffer_used);
		/*
		for(int i = 0; i < pckt_length; i++){
			snprintf(buffer, sizeof(buffer), "%i", p_rx_packet[i]);
			MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)buffer);
		}
		*/

		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"\n\rDATA DONE\n\r");
		MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"========================\n\r");

		for(int i = 0; i < 1024; i++){
			fft_load_smpl(&fft_fab, p_rx_packet[i + 42], 0u);
		}

		fft_load_done(&fft_fab);


	}
	else if(2 == port_check){
		
		uint16_t fft_result_real[513];
		uint16_t fft_result_imag[513];
		uint16_t fft_result_abs;

		for(int i = 0; i < 513; i++){
			fft_read_smpl(&fft_fab, (uint16_t)i, fft_result_real[i], fft_result_imag[i], fft_result_abs);
			g_mac_tx_buffer[i + 12] = (uint8_t)fft_result_abs;
		}
		MSS_MAC_send_pkt(g_mac_tx_buffer, 64u, (void *)&g_mac_tx_buffer_used);

	}
	else if(3 == port_check){
		fft_read_done(&fft_fab);
	}

	MSS_MAC_receive_pkt(g_mac_rx_buffer, 0);

}

char eth_check_address(uint8_t * packet_data){
	/* Check Destination address */
	if(packet_data[30] == 169 && packet_data[31] == 254 && packet_data[32] == 255 && packet_data[33] == 255){
		/* Check Destination port */
		if(packet_data[36] == 0xBE && packet_data[37] == 0xEF){
			MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"BEEF received, reading data\n\r");
			return 1u;
		}
		else if(packet_data[36] == 0xDE && packet_data[37] == 0xAD){
			MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"DEAD received, returning data\n\r");
			return 2u;
		}
		else if(packet_data[36] == 0xb0 && packet_data[37] == 0x0b){
			MSS_UART_polled_tx_string(&g_mss_uart0, (const uint8_t *)"B00B received, done reading data\n\r");
			return 3u;
		}
	}
	return 0u;
}
